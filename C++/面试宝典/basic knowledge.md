
#####  C++ 的内存模型
1. 栈区(Stack): 用于存储局部变量、函数参数和函数返回地址等。栈区的分配和释放由编译器自动管理，它的特点是后进先出(LIFO)的结构。
2. 堆区(Heap): 用于动态分配和释放内存。 C++ 中通过 new 和 delete 或 malloc 和 free 等方法在堆区进行内存分配和释放。堆区是一片较大的内存空间，它的分配和释放需要手动进行，如果未正确释放，可能导致内存泄露。
3. 全局区(Global/Static Data): 存储全局变量、静态变量和静态对象。全局区在程序启动时分配，程序结束时释放，它的生命周期和程序的运行时间一样长。
4. 常量区(Const/Data Segment): 存储常量数据，如字符串常量、全局常量和静态常量。常量区通常位于可执行文件的特定节(section)，在程序运行期间保持不变。
5. 代码区(Code/Text Segment)：存储程序的二进制指令，也称为文本区。代码区通常是只读的，不可修改。

##### C++和C的区别
* 设计思想上：
	* C++是面向对象的语言，而C是面向过程的结构化编程语言
* 语法上：
	* C++具有重载，继承和多态三种特性
	* C++相比C，增加许多类型安全的功能，比如强制类型转换
	* C++支持范式编程，比如模板类，函数模板等

#####  C/C++ 中指针和引用的区别？

1. 指针有自己的一块空间，而引用只是一个别名。
2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。
3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用。
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。
5. 可以有const指针，但是没有const引用。
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变。
7. 指针可以有多级指针(**p)，而引用只有一级。
8. 指针和引用使用++运算符的意义不一样。
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。

##### static 关键字的作用

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定义为static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。
5. 静态使用时注意点:
	1. 静态方法只能访问静态成员(包括成员变量和成员方法)
	2. 非静态方法可以访问静态也可以访问非静态
	3. 静态方法中不可以定义this，super关键字
	4. 因为 一个类中，一个static变量只会有一个内存空间，虽然有多个类实例，但这些类实例中的这个static变量会共享同一个内存空间。静态方法在优先于对象存在，所以静态方法中不可以出现this，super关键字。
	5. 主函数是静态的。程序运行的时候，静态成员已经加载在内存里面了，但是包含静态成员的对象共享这些静态成员，比方说，A有一个静态成员public static int i;那么程序运行的时候，这个i就加载进内存了，A的所有对象的i变量都指向这个静态空间的i，也就是说创建对象之前，它就占空间了。
		1. 只有类的成员函数才能说明为虚函数
		2. 静态成员函数不能是虚函数
		3. 内联函数不能为虚函数
		4. 构造函数不能是虚函数
		5. 析构函数可以是虚函数，而且通常声明为虚函数

##### 野指针

1. 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针




##### C++中四种cast转换

* static_cast: 完成基础数据类型，同一个继承体系中类型的转换，任意类型与空指针类型void* 之间的转换。
* dynamic_cast: 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上(指的是子类向基类的转换)和向下转化(指的是基类向子类的转换)。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
* const_cast: 对于未定义const版本的成员函数，我们通常使用const_cast 来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
* reinterpret_cast: 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用。

##### C++中的四个智能指针
智能指针出现的原因：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

1. auto_ptr(c++98的方案，c++11已经抛弃): 原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。
2. unique_ptr(替换auto_ptr): 是C++11才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个pointer拥有。一旦拥有着被销毁或编程empty，或是开始拥有另外一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。实现独占式拥有(exclusive ownership)或严格拥有(strict ownership)概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏(resource leak)如 new 后忘记 delete ——特别有用。unique_ptr 用于取代 auto_ptr.
3. shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。
4. weak_ptr 允许你共享但不拥有某对象，通常不单独使用，只能和 shared_ptr 类型指针搭配使用, 一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题。



##### 为什么析构函数必须是虚函数？
- 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

##### 为什么C++默认的析构函数不是虚函数
* C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。


##### 函数指针
函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。
##### C++中析构函数的作用
* 析构函数与构造函数对应，当对象结束其生命周期，如对象所在函数已调用完毕时，系统会自动执行析构函数。
* 析构函数名也应与类名相同，只是在函数名前加取反符~，它不能带任何参数，也没有返回值（包括void类型）。**只能有一个析构函数，不能重载**。
* 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作，所以许多简单的类中没有用显式的析构函数。
* 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显式构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。
* 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。


##### 静态函数和虚函数的区别
* 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。
##### 重载和重写
- 重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
- 重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

##### 虚函数和多态
* 多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。
* 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
##### const修饰成员函数的目的是什么？
- const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

##### C++里是怎么定义常量的？常量存放在内存的哪个位置？
- 对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。