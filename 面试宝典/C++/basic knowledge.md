
##### C++ 的内存分布
1. 栈区(Stack): 用于存储局部变量、函数参数和函数返回地址等。栈区的分配和释放由编译器自动管理，它的特点是后进先出(LIFO)的结构。
2. 堆区(Heap): 用于动态分配和释放内存。 C++ 中通过 new 和 delete 或 malloc 和 free 等方法在堆区进行内存分配和释放。堆区是一片较大的内存空间，它的分配和释放需要手动进行，如果未正确释放，可能导致内存泄露。
3. 全局区(Global/Static Data): 存储全局变量、静态变量和静态对象。全局区在程序启动时分配，程序结束时释放，它的生命周期和程序的运行时间一样长。
4. 常量区(Const/Data Segment): 存储常量数据，如字符串常量、全局常量和静态常量。常量区通常位于可执行文件的特定节(section)，在程序运行期间保持不变。
5. 代码区(Code/Text Segment)：存储程序的二进制指令，也称为文本区。代码区通常是只读的，不可修改。

##### C++源文件从文本到可执行文件经历的过程？
* 对于C++源文件，从文本到可执行文件一般需要四个过程：
	* 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
	* 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
	* 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
	* 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件
##### C++和C的区别
* 设计思想上：
	* C++是面向对象的语言，而C是面向过程的结构化编程语言
* 语法上：
	* C++具有重载，继承和多态三种特性
	* C++相比C，增加许多类型安全的功能，比如强制类型转换
	* C++支持范式编程，比如模板类，函数模板等

##### C/C++ 中指针和引用的区别？

1. 指针有自己的一块空间，而引用只是一个别名。
2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。
3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用。
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。
5. 可以有const指针，但是没有const引用。
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变。
7. 指针可以有多级指针(**p)，而引用只有一级。
8. 指针和引用使用++运算符的意义不一样。
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。

##### static 关键字的作用

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定义为static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。
5. 静态使用时注意点:
	1. 静态方法只能访问静态成员(包括成员变量和成员方法)
	2. 非静态方法可以访问静态也可以访问非静态
	3. 静态方法中不可以定义this，super关键字
	4. 因为 一个类中，一个static变量只会有一个内存空间，虽然有多个类实例，但这些类实例中的这个static变量会共享同一个内存空间。静态方法在优先于对象存在，所以静态方法中不可以出现this，super关键字。
	5. 主函数是静态的。程序运行的时候，静态成员已经加载在内存里面了，但是包含静态成员的对象共享这些静态成员，比方说，A有一个静态成员public static int i;那么程序运行的时候，这个i就加载进内存了，A的所有对象的i变量都指向这个静态空间的i，也就是说创建对象之前，它就占空间了。
		1. 只有类的成员函数才能说明为虚函数
		2. 静态成员函数不能是虚函数
		3. 内联函数不能为虚函数
		4. 构造函数不能是虚函数
		5. 析构函数可以是虚函数，而且通常声明为虚函数

##### 野指针

1. 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针




##### C++中四种cast转换

* static_cast: 完成基础数据类型，同一个继承体系中类型的转换，任意类型与空指针类型void* 之间的转换。
* dynamic_cast: 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上(指的是子类向基类的转换)和向下转化(指的是基类向子类的转换)。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
* const_cast: 对于未定义const版本的成员函数，我们通常使用const_cast 来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
* reinterpret_cast: 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用。

##### C++中的四个智能指针
智能指针出现的原因：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

1. auto_ptr(c++98的方案，c++11已经抛弃): 原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。
2. unique_ptr(替换auto_ptr): 是C++11才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个pointer拥有。一旦拥有着被销毁或编程empty，或是开始拥有另外一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。实现独占式拥有(exclusive ownership)或严格拥有(strict ownership)概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏(resource leak)如 new 后忘记 delete ——特别有用。unique_ptr 用于取代 auto_ptr.
3. shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。
4. weak_ptr 允许你共享但不拥有某对象，通常不单独使用，只能和 shared_ptr 类型指针搭配使用, 一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题。



##### 为什么析构函数必须是虚函数？
- 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

##### 为什么C++默认的析构函数不是虚函数
* C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。


##### 函数指针
函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。
##### C++中析构函数的作用
* 析构函数与构造函数对应，当对象结束其生命周期，如对象所在函数已调用完毕时，系统会自动执行析构函数。
* 析构函数名也应与类名相同，只是在函数名前加取反符~，它不能带任何参数，也没有返回值（包括void类型）。**只能有一个析构函数，不能重载**。
* 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作，所以许多简单的类中没有用显式的析构函数。
* 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显式构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。
* 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。


##### 静态函数和虚函数的区别
* 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。
##### 重载和重写
- 重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
- 重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

##### 虚函数和多态
* 多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。
* 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
##### const修饰成员函数的目的是什么？
- const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

##### C++里是怎么定义常量的？常量存放在内存的哪个位置？
- 对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。

##### new/delete与malloc/free的区别是什么？
- 首先，new/delete是C++的关键字，而malloc/free是C语言的库函数；后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数。
##### 虚函数表具体是怎样实现运行时多态的？
子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在vs中，对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。
##### C语言是怎么进行函数调用的？
- 每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。
##### C++如何处理返回值？
- 生成一个临时变量，把它的引用作为函数参数传入函数内。
##### C++中类成员的访问权限
C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。
##### C++中struct和class的区别
- 总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
- 区别：最本质的一个区别就是默认的访问控制默认的继承访问权限。struct 是 public 的，class 是 private 的struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。
##### C++类的内部可以定义引用数据成员吗？
可以，必须通过构造函数初始化列表初始化
##### 什么是右值引用，跟左值又有什么区别？
- 右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。
- 左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。
- 右值引用和左值引用的区别：
	- 左值可以寻址，而右值不可以
	- 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值
	- 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）


##### 什么时候会发生段错误？
* 段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：
	* 使用野指针
	* 试图修改字符串常量的内容
##### C++11有哪些新特性？
- auto关键字：编译器可以根据初始值自动推导出类型，但是不能用于函数传参以及数组类型的推导
- nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
- 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。
- 初始化列表：使用初始化列表来对类进行初始化
- 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
- atomic原子操作用于多线程资源互斥操作
- 新增STL容器array以及tuple
##### inline内联函数
* 内联函数的特点：
	* 相当于把内联函数里面的内容写在调用内联函数处
	* 相当于不用执行进入函数的步骤，直接执行函数体
	* 相当于宏，却比宏多了类型检查，真正具有函数特性
	* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数
	* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数
##### union联合体
联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。
联合有如下特点：
* 默认访问控制符为 public
* 可以含有构造函数、析构函数
* 不能含有引用类型的成员
* 不能继承自其他类，不能作为基类
* 不能含有虚函数
* 匿名 union 在定义所在作用域可直接访问 union 成员
* 匿名 union 不能包含protected成员或private成员
* 全局匿名联合必须是静态(static)
```
#include<iostream>

union UnionTest {
    UnionTest() : i(10) {};
    int i;
    double d;
};

static union {
    int i;
    double d;
};

int main() {
    UnionTest u;

    union {
        int i;
        double d;
    };

    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10

    ::i = 20;
    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20

    i = 30;
    std::cout << i << std::endl;    // 输出局部匿名联合的 30

    return 0;
}
```


##### friend友元类和友元函数
- 能访问私有成员、破坏封装性、友元关系不可传递、友元关系的单向性、友元声明的形式及数量不受限制
##### :: 范围解析运算符
* 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
* 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
* 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

```
int count = 0;        // 全局（::）的 count

class A {
public:
    static int count; // 类 A 的 count（A::count）
};

int main() {
    ::count = 1;      // 设置全局的 count 的值为 1

    A::count = 2;     // 设置类 A 的 count 为 2

    int count = 0;    // 局部的 count
    count = 3;        // 设置局部的 count 的值为 3

    return 0;
}
```

##### enum枚举类型

* 限定作用域的枚举类型
	* enum class open_modes { input, output, append };
* 不限定作用域的枚举类型
	* enum color { red, yellow, green }; 
	* enum { floatPrec = 6, doublePrec = 10 };

##### decltype关键字
decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

##### 引用和宏
- 左值引用：常规引用，一般表示对象的身份
- 右值引用：右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值；右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：
	* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
	* 能够更简洁明确地定义泛型函数。
* 引用折叠： X& &、X& &&、X&& & 可折叠成 X&；X&& && 可折叠成 X&&
* 宏：宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，**在宏展开的时候对 “参数” 进行的是一对一的替换**。
##### 面向对象三大特征
* **封装**：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。
	* public 成员：可以被任意实体访问
	* protected 成员：只允许被子类及本类的成员函数访问
	* private 成员：只允许被本类的成员函数、友元类或友元函数访问
- **继承**：基类（父类）——> 派生类（子类）
- **多态**：即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。**多态是以封装和继承为基础的**。
	- C++ 多态分类及实现：
		- 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
		- 子类型多态（Subtype Polymorphism，运行期）：虚函数
		- 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
		- 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

##### 静态多态(编译期/早绑定)
```
class A 
{ 
	public: 
		void do(int a); 
		void do(int a, int b); 
};
```

##### 虚析构函数
* 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。
```
class Shape
{
public:
    Shape();                    // 构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();           // 虚析构函数
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1->calcArea();
    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
    shape1 = NULL;
    return 0；
}
```

##### 纯虚函数
纯虚函数是一种特殊的虚函数，**在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做**。

##### 虚函数、纯虚函数
- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
- 虚基类是虚继承中的基类。


##### 虚函数指针、虚函数表
- 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
- 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

##### 虚继承
- 用途：用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）
- 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。


##### 模板类、成员模板、虚函数
- 模板类中可以使用虚函数
- 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数

##### 抽象类、接口类、聚合类
- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
	- 所有成员都是 public
	- 没有定义任何构造函数
	- 没有类内初始化
	- 没有基类，也没有 virtual 函数

