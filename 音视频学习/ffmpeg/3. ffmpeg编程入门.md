
## 常用概念


### 编解码流程

![ffmpeg编解码流程](../../resource/音视频学习/ffmpeg编解码流程.png)

![ffmpeg音视频播放原理](../../resource/音视频学习/ffmpeg音视频播放原理.png)

### 常用音视频术语

* 容器／文件（Conainer/File）：即特定格式的多媒体文件，比如mp4、flv、mkv等。
* 媒体流（Stream）：表示时间轴上的一段连续数据，如一段声音数据、一段视频数据或一段字幕数据，可以是压缩的，也可以是非压缩的，压缩的数据需要关联特定的编解码器（有些码流音频他是纯PCM）。
* 数据帧／数据包（Frame/Packet）：通常，一个媒体流是由大量的数据帧组成的，对于压缩数据，帧对应着编解码器的最小处理单元，分属于不同媒体流的数据帧交错存储于容器之中。
* 编解码器：编解码器是以帧为单位实现压缩数据和原始数据之间的相互转换的。

在多媒体处理中，协议（protocol）、demuxer（解复用器）和muxer（复用器）是三个关键层。
首先，协议（protocol）层是指用于传输数据的协议，例如HTTP、RTMP、RTSP等。协议层负责发送和接收多媒体数据，确保数据的可靠传输。
接下来是demuxer层，也称为解复用器。它的作用是从输入媒体流中提取出不同的音频、视频、字幕等元素。解复用器将输入的媒体流拆分为多个独立的轨道，以便后续的处理。它解析媒体容器格式，并根据媒体元数据信息将其解复用为独立的媒体流。
最后是muxer层，也称为复用器。它的作用是将不同的音频、视频、字幕等元素合并为一个完整的媒体流，并将其封装为特定的媒体容器格式，例如MP4、AVI、MKV等。复用器负责将独立的媒体流重新组合为一个整体，以便在播放器或其他设备上播放或传输。
这三个层级在多媒体处理中扮演着重要的角色，协同工作以实现媒体的传输、解析和合成。

### 复用器

![音视频学习-复用器](../../resource/音视频学习/音视频学习_复用器.png)

![音视频学习-解复用器](../../resource/音视频学习/音视频学习_解复用器.png)

### 编解码器

![音视频学习-编解码器](../../resource/音视频学习/音视频学习_编解码器.png)

## FFmpeg 库简介

![音视频学习_ffmpeg整体结构](../../resource/音视频学习/音视频学习_ffmpeg整体结构.png)

### ffmpeg常用库

ffmpeg有8个常用库:

* AVUtil：核心工具库，下面的许多其他模块都会依赖该库做一些基本的音视频处理操作。
* AVFormat：文件格式和协议库，该模块是最重要的模块之一，封装了Protocol层和Demuxer、Muxer层，使得协议和格式对于开发者来说是透明的。
* AVCodec：编解码库，封装了Codec层，但是有一些Codec是具备自己的License的，FFmpeg是不会默认添加像libx264、FDK-AAC等库的，但是FFmpeg就像一个平台一样，可以将其他的第三方的Codec以插件的方式添加进来，然后为开发者提供统一的接口。
* AVFilter：音视频滤镜库，该模块提供了包括音频特效和视频特效的处理，在使用FFmpeg的API进行编解码的过程中，直接使用该模块为音视频数据做特效处理是非常方便同时也非常高效的一种方式。


### ffmpeg函数简介

#### 初始化相关

* av_register_all(): 注册所有组件，4.0已经弃用
* avdevice_register_all(): 对设备进行注册，比如V4L2等。
* avformat_network_init(): 初始化网络库以及网络加密协议相关的库(比如openssl)

#### 封装格式相关

* avformat_alloc_context(): 负责申请一个AVFormatContext结构的内存，并进行简单初始化
* avformat_free_context(): 释放该结构里的所有东西以及该结构本身
* avformat_close_input(): 关闭解复用器。关闭后就不再需要使用avformat_free_context 进行释放。
* avformat_open_input(): 打开输入视频文件。
* avformat_find_stream_info(): 获取音视频文件信息
* av_read_frame(): 读取音视频包
* avformat_seek_file(): 定位文件
* av_seek_frame(): 定位文件

![音视频学习-封装格式相关](../../resource/音视频学习/音视频学习-封装格式相关.png)


#### 解码器相关

* avcodec_alloc_context3(): 分配解码器上下文
* avcodec_find_decoder(): 根据ID查找解码器
* avcodec_find_decoder_by_name(): 根据解码器名字
* avcodec_open2(): 打开编解码器
* avcodec_decode_video2(): 解码一帧视频数据(ffmpeg <= 3版本使用)
* avcodec_decode_audio4(): 解码一帧音频数据(ffmpeg <= 3版本使用)
* avcodec_send_packet(): 发送编码数据包
* avcodec_receive_frame(): 接收解码后数据
* avcodec_free_context(): 释放解码器上下文，包含了avcodec_close()
* avcodec_close(): 关闭解码器

![音视频学习-解码器相关](../../resource/音视频学习/音视频学习-解码器相关.png)


### 组件注册方式

#### ffmpeg 3.x

我们使用ffmpeg，首先要执行av_register_all，把全局的解码器、编码器等结构体注册到各自全局的对象链表里，以便后面查找调用。

![音视频学习-.ffmpeg3组件注册方式](../../resource/音视频学习/音视频学习-.ffmpeg3组件注册方式.png)

#### ffmeg 4.x 

FFmpeg内部去做，不需要用户调用API去注册。
以codec编解码器为例:

1. 在configure的时候生成要注册的组件

./configure:7203:print_enabled_components libavcodec/codec_list.c AVCodec codec_list $CODEC_LIST
这里会生成一个codec_list.c文件，里面只有static const AVCodec *const codec_list[]数组。

2. 在libavcodec/allcodecs.c将static const AVCodec *const codec_list[]的编解码器用链表的方式组织起来。

#### ffmpeg 4.0.2 

FFmepg内部去做，不需要用户调用API去注册。

对于demuxer/muxer（解复用器，也称容器）则对应
1. libavformat/muxer_list.c
libavformat/demuxer_list.c 这两个文件也是在configure的时候生成，
也就是说直接下载源码是没有这两个文件的。
2. 在libavformat/allformats.c将demuxer_list[]和muexr_list[]以链表的方
式组织。
其他组件也是类似的方式。

### ffmpeg 数据结构简介

* AVFormatContext
  * 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息
* AVInputFormat demuxer
  * 每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。
* AVOutputFormat muxer
* AVStream
  * 视频文件中每个视频（音频）流对应一个该结构体。
* AVCodecContext
  * 编解码器上下文结构体，保存了视频（音频）编解码相关信息。
* AVCodec
  * 每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。
* AVPacket
  * 存储一帧压缩编码数据。
* AVFrame
  * 存储一帧解码后像素（采样）数据。

#### 数据结构之间的关系

AVFormatContext和AVInputFormat之间的关系
AVFormatContext API调用
AVInputFormat 主要是FFMPEG内部调用

AVFormatContext 封装格式上下文结构体:

```c++
// 数据
struct AVInputFormat *iformat;
```

所有方法可重入的

```c++
// 方法
//AVInputFormat 每种封装格式(例如FLV，MKV，MP4)
int(*read_header)(struct AVFormatContext *);
int(*read_packet)(struct AVFormatContext *, AVPacket *pkt);

int avformat_open_input(AVFormatContext **ps, const char *filename,
                        AVInputFormat *fmt, AVDictionary **options);


```

AVCodecContext和AVCodec之间的关系

```c++
// 数据
// AVCodecContext编码器上下文结构体
struct AVCodec *codec; 

// 方法
// AVCodec 每种视频（音频）解码器
int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt);

int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr);
```

AVFormatContext, AVStream和AVCodecContext之间的关系



![AVFormatContext, AVStream和AVCodecContext之间的关系](../../resource/音视频学习/音视频学习-AVFormatContext和AVStream和AVCodecContext之间的关系.png)


##### 区分不同的码流

* AVMEDIA_TYPE_VIDEO 视频流
  * ```c++
        video_index = av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,
                                        -1, -1, NULL, 0);
    ```
* AVMEDIA_TYPE_AUDIO 音频流
  * ```c++
        audio_index = av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,
                                        -1, -1, NULL, 0);
    ```

AVPacket 里面也有一个index的字段

![音视频学习-AVPacket和AVFrame之间的关系](../../resource/音视频学习/音视频学习-AVPacket和AVFrame之间的关系.png)


#### 数据结构分析

* AVFormatContext
    * iformat：输入媒体的AVInputFormat，比如指向AVInputFormat ff_flv_demuxer
    * nb_streams：输入媒体的AVStream 个数
    * streams：输入媒体的AVStream []数组
    * duration：输入媒体的时长（以微秒为单位），计算方式可以参考av_dump_format()函数。
    * bit_rate：输入媒体的码率

* AVInputFormat
  * name：封装格式名称
  * extensions：封装格式的扩展名
  * id：封装格式ID
  * 一些封装格式处理的接口函数,比如read_packet()


* AVStream
  * index：标识该视频/音频流
  * time_base：该流的时基，PTS*time_base=真正的时间（秒）
  * avg_frame_rate： 该流的帧率
  * duration：该视频/音频流长度
  * codecpar：编解码器参数属性

* AVCodecParameters
  * codec_type：媒体类型，比如AVMEDIA_TYPE_VIDEO AVMEDIA_TYPE_AUDIO等
  * codec_id：编解码器类型， 比如AV_CODEC_ID_H264 AV_CODEC_ID_AAC等。

* AVCodecContext
  * codec：编解码器的AVCodec，比如指向AVCodec ff_aac_latm_decoder
  * width, height：图像的宽高（只针对视频）
  * pix_fmt：像素格式（只针对视频）
  * sample_rate：采样率（只针对音频）
  * channels：声道数（只针对音频）
  * sample_fmt：采样格式（只针对音频）

* AVCodec
  * name：编解码器名称
  * type：编解码器类型
  * id：编解码器ID
  * 一些编解码的接口函数，比如int (*decode)()

* AVPacket
  * pts：显示时间戳
  * dts：解码时间戳
  * data：压缩编码数据
  * size：压缩编码数据大小
  * pos:数据的偏移地址
  * stream_index：所属的AVStream

* AVFrame
  * data：解码后的图像像素数据（音频采样数据）
  * linesize：对视频来说是图像中一行像素的大小；对音频来说是整个音频帧的大小
  * width, height：图像的宽高（只针对视频）
  * key_frame：是否为关键帧（只针对视频） 。
  * pict_type：帧类型（只针对视频） 。例如I， P， B
  * sample_rate：音频采样率（只针对音频）
  * nb_samples：音频每通道采样数（只针对音频）
  * pts：显示时间戳